
- [动态内存](##第12章动态内存)
- [模板与泛型编程](##第16章模板与泛型编程(简版待补充完全))

# <font color="#00BB00">第I部分 C++基础</font>

## <font color="#AA0000"> 第2章  变量和基本类型 </font>


## <font color="#AA0000"> 第7章  类 </font>

## 第12章 动态内存

除了自动和static对象外,C++还支持动态分配对象。动态分配的对象生存期与它们在哪里创建无关,只有当显式地被释放时，这些对象才会销毁。动态对象正确释放是个极其容易出错的地方,为了更安全的使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动的释放它。

### 12.1 动态内存与智能指针
在C++中，动态内存的管理是通过一对运算符来完成的：new，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式:
shared_ptr 允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向 shared_ptr所管理的对象。这三种类型都定义在memory头文件中。

#### 1  shared_ptr类

智能指针也是模板，当我们创建一个智能指针时，必须提供额外的信息(指针可以指向的类型)。默认初始化的智能指针中保存着一个空指针。

```C++

```

下表列出了shared_ptr 和 unique_ptr都支持的操作。

| shared_ptr 和 unique_ptr都支持的操作。 |                                                              |
| -------------------------------------- | ------------------------------------------------------------ |
| shared_ptr<T> sp 或者 unique_ptr<T> up | 空智能指针，可以指向类型为T的对象                            |
| p                                      | 将p用作一个条件判断，若p指向一个对象，则为true               |
| *p                                     | 解引用p,获得它指向的对象                                     |
| p->mem                                 | 等价于（*p）.mem                                             |
| p.get()                                | 返回p中保存的指针，要小心使用,若智能指针释放了其对象<br>返回的指针所指向的对象也就消失了 |
| swap(p,q)<br>p.swap(q)                 | 交换p和q中的指针                                             |

shared_ptr 独有的操作：

待补充

###  <font color="red">12.2 直接管理内存</font>

C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete释放new分配的内存。相对于智能指针，使用这两个运算符管理内存非常容易出错，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。

```C++
    /*- 在自由空间分配的内存是无名的,因此new无法为其分配的对象命名,而是返回一个指向该对象的指针  */
    int *pi0 = new int; //pi0指向一个动态分配的、未初始化的无名对象 , 此new表达式在自由空间构造一个int型对象,并返回指向该对象的指针。

    /*- 默认情况下,动态分配的对象是默认初始化的, 这意味着内置类型或组合类型的对象的值将是未定义的,而类类型对象将用默认构造函数进行初始化 */
    string *ps = new string; //初始化为空string 
    int    *pi = new int;    //pi指向一个未初始化的int

    /*-  我们可以用直接初始化方式来初始化动态分配的对象,我们可以使用传统的构造方式（使用圆括号）,在新标准下,也可以使用列表初始化（使用花括号）*/
    int *pii = new int(1024);//pii 指向的对象的值为1024
    string *ps1 = new string(10,'9');//*ps1为"9999999999"
    //vector有10个元素,值依次从0到9
    vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9}; 

    /*- 也可以对动态分配的对象进行初始化,只需要在类型名后加一对空括号即可  */
    string *ps_test  = new string ; /*- 默认初始化为空string   */
    string *ps_test1 = new string() ; /*- 值初始化为空string   */

    int *pi_test1 = new int ; /*- 默认初始化  *pi_test1值未定义  */
    int *pi_test2 = new int() ; /*- 值初始化为0  *pi_test2为0    */
    /*- 对于定义了自己的构造函数的类类型（例如string）来说, 要求值初始化是没有意义的;
        不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了;
        值初始化的内置类型对象有着良好定义的值, 而默认初始化的对象的值则是未定义的。
        类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的 
    */
```

动态分配const对象：

```C++
    /*- 用new分配const对象是合法的   */
    //分配并初始化一个const int 
    const int *pci = new const int(1024); 
    //分配并默认初始化一个const的空string
    const string *pcs = new const string; 
    /*-  类似其他任何const对象,一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型, 其const动态对象可以隐式初始化,
         而其他类型的对象就必须显式初始化。由于分配的对象是const的, new返回的指针是一个指向const的指针  */

    /*- 虽然现代计算机通常都配备大容量内存, 但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存,new表达式就会失败。
        默认情况下，如果new不能分配所要求的内存空间,它会抛出一个类型为 bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常  */
    //如果分配失败，new返回一个空指针
    int *pl = new int; //如果分配失败，new抛出std::bad alloc 
    int *p2 = new (nothrow) int; //如果分配失败，new返回一个空指针

    /*- 我们称这种形式的new为定位new(placement new), 定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。
        如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad alloc和nothrow都定义在头文件new中。 
    */

```

释放动态内存：

```C++
    int *p = new int ;
   /*-  为了防止内存耗尽,在动态内存使用完毕后,必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。
       delete表达式接受一个指针,指向我们想要释放的对象： */ 
    delete p; //p必须指向一个动态分配的对象或是一个空指针与new类型类似,delete表达式也执行两个动作:销毁给定的指针指向的对象; 释放对应的内存。

    /*-  我们传递给delete的指针必须指向动态分配的内存,或者是一个空指针。释放一块并非new分配的内存,或者将相同的指针值释放多次,其行为是未定义的 */
    int i, *pil=&i, *pi2=nullptr;
    double *pd=new double(33), *pd2=pd ;
    // delete i ;//错误：i不是一个指针
    //delete pi1;//未定义：pi1指向一个局部变量
    delete pd ;//正确
    delete pd2;//未定义：pd2指向的内存已经被释放了
    delete pi2;//正确: 释放一个空指针总是没有错误的
    /*- 对于delete i 的请求,编译器会生成一个错误信息,因为它知道i不是一个指针。
        执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下,编译器不能分辨一个指针指向的是静态还是动态分配的对象。
        类似的,编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些delete表达式,大多数编译器会编译通过,尽管它们是错误的。 
    */
   /*-  虽然一个const对象的值不能被改变,但它本身是可以被销毁的。如同任何其他动态对象一样,想要释放一个const动态对象,只要delete指向它的指针即可 */
   const int *pci = new const int(1024); 
   delete pci; //正确：释放一个const对象

```

使用new和delete管理动态内存存在三个常见问题：

- 1.忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。
- 2.使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。
- 3.同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。
  相对于查找和修正这些错误来说，制造出这些错误要简单得多。坚持只使用智能指针，就可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它。



## <font color="#AA0000">第16章 模板与泛型编程(简版待补充完全)</font>

可以定义一个通用的函数模板,一个函数模板就是一个公式,可以生成针对特定版本的函数。
模板定义以关键字template开始,后跟一个模板参数列表,这是一个逗号分隔的一个或多个模板参数列表，用<>包围起来,<font color="red">在模板定义中模板参数列表不能为空</font>

```C++
#include <iostream>
    
using  namespace  std ;
    
template<typename T>
int compare( T &v1, T &v2 ){
    if(v1<v2 ) {
        return -1;
    }
    else if(v1>v2) {
        return 1 ;
    }
    else{
        return 0 ;
    }
}

int  main(int argc,char **argv)
{
    int a =1 ,b =2 ;
    cout << compare(a,b) << endl ;
    float c = 2.5 , d = 2.1 ;
    cout << compare<float>(c,d) << endl ; /*-  显式指定调用  */
    return 0 ;
}
```